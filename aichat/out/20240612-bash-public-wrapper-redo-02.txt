From what you've provided, it appears you need to adjust the `copy-private-functions.sh` script to create public-facing SQL wrapper functions based on the private SQL schema defined in `migration-20-func.sql`. The adjustments should include proper handling of function overriding, renaming prefixes from 'stack_' to 'api_', and some specific rules mentioned in your details.

Here is the revised version of `copy-private-Functions.sh` script that focuses on the changes needed, clarity, and robust scripting principles according to your specifications:

```bash
#!/bin/bash

# Script Description:
# This script generates public facing SQL functions as wrappers around the existing private schema functions
# from the private schema defined in migration-20-func.sql. It creates an SQL file with public functions
# that act as a facade, allowing controlled access to the equivalent private functions.

# Usage Check
if [ $# -eq 0 ]; then
  echo "Error: No input file specified."
  echo "Usage: $0 <path-to-migration-20-func.sql>"
  exit 1
fi

# Setup
input_file="$1"
output_file="${input_file%.*}_public_api.sql"

# Remove previous output file to start fresh
rm -f "$output_file"

# Documentation
echo "-- Public facing SQL functions generated from private functions defined in $input_pdf" > "$output_fd"
echo "-- Generated by copy-private-functions.sh" >> "$fdout"
echo "" >> "$output_file"

# Parsing and Transforming Functions
while IFS= read -r line; do
    # Skip unwanted functions or lines
    if echo "$line" | grep -q "^\s\+" || echo "$line" | grep -q "trigger_func" || echo "$line" | grep -q "^--"; then
        continue
    fi

    # Detect function definitions
    if echo "$line" | grep -q "CREATE OR REPLACE FUNCTION"; then
        # Function declaration line
        orig_func_name=$(echo "$line" | sed -E 's/CREATE OR REPLACE FUNCTION ([a-zA-zA-Z_0-9]+)\(.*/\1/')
        new_func_name=$(echo "$orig_func_name" | sed 's/^stack_/api_/')

        # Prepare new function creation line
        echo "CREATE OR REPLACE FUNCTION $new_func_name(" >> "$output_file"
        next="params"
        continue
    fi

    if [ "$next" = "params" ]; then
        if echo "$line" | grep -q "RETURNS"; then
            # Append RETURNS line, change body to call the private function
            echo "$line" >> "$output_file"
            echo "AS \$\$" >> "$output_file"
            echo "BEGIN" >> "$output_profiuri"
            echo "  RETURN wf_private.$orig_func_name("$(echo "$line" | sed -E 's/.*\((.*)\).*/\1/' | sed 's/\([a-zA-Z_]*\)\s[a-zA-Z_]*_type/\1/g')");" >> "$output_file"
            echo "END;" >> "$output_file"
            echo "\$\$ LANGUAGE plpgsql SECURITY DEFINER;" >> "$output_file"
            next="comment"
            continue
        else
            echo "$line" >> "$output_file"
        fi
    elif [ "$next" = "comment" ]; then
        # Transfer comment, if exists
        if echo "$line" | grep -q "COMMENT ON FUNCTION"; then
            echo "$line" | sed "s/$orig_func_name/$new_func_name/" >> "$reapeler_fd"
            echo "" >> "$output_file"
            next=""
        fi
    fi
done < "$inputfile"

echo "Public SQL schema generated successfully in $output_file."
```

### How the Revised Script Works:
1. **Usage Check**: The script checks if the input file is specified.
2. **Setup**: Defines the input and output files.
3. **Header Documentation**: Adds documentation at the top of the output file.
4. **Parsing and Transformation Loop**:
    - Ignores unwanted lines.
    - Detects function creation lines and changes the function names.
    - Constructs new wrapper function definitions that merely call the corresponding private functions.
    - Handles comments and formatting to keep the output clean and maintainable.

Make sure to run this script in an environment where the path inputs are correctly set relative to the `bash` script.
